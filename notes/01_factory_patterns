-----------------------------------------------------------
CHAPTER 1 - THE FACTORY PATTERNS
-----------------------------------------------------------

- Gang Of Four

    - The patterns here were popularized by the book 'Design Patterns: Elements of Reusable 
        Object-Oriented Software' by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.


    - The GoF defined 23 original design patterns:

        Creational:
          1. Factory Method
          2. Abstract Factory
          3. Builder
          4. Prototype
          5. Singleton

        Structural:
          6. Adapter
          7. Decorator
          8. Bridge
          9. Facade
          10. Flyweight
          11. Composite
          12. Proxy

        Behavioral:
          13. Chain of Responsibility
          14. Command
          15. Observer
          16. State
          17. Interpreter
          18. Strategy
          19. Memento
          20. Iterator
          21. Template
          22. Mediator
          23. Visitor



- Creational Design Patterns

    - Creational design patterns deal with different aspects of object creation.  Their goal is to 
        provide better alternatives for situations where direct object creation ('__init__()' calls)
        is not convenient.



- Factory Patterns

    - In the factory design pattern, a client asks for an object without knowing which class is used
        to generate it.  This simplifies the object creation process, because it is easier to track
        which objects are created if this is done through a central function.


    - A factory reduces complexity by decoupling the code that creates an object from the code that
        uses it.


    - Factories typically come in 2 forms:

        1. Factory Method   = a method that returns a different object per input parameter

        2. Abstract Factory = a group of factory methods used to create a family of related objects



- The Factory Method

    - The factory method is based on a single function written to handle our object creation task.  
        We execute it, passing a parameter that provides information about what we want, and as a result,
        the desired object is created.  We are not required to know how the resulting object is
        implemented.


    - If you realize you cannot track the objects created in your application because the code that
        creates them is in many different places, consider using the factory method pattern.



- Factory Method Example

    - In this example, we'll create a client that can read both XML and JSON files.


        # movies.json
        [
          {"title":"After Dark in Central Park",
           "year":1900, 
           "director":null, "cast":null, "genre":null},
          {"title":"Boarding School Girls' Pajama Parade",
           "year":1900, 
           "director":null, "cast":null, "genre":null},
          {"title":"Buffalo Bill's Wild West Parad",
           "year":1900, 
           "director":null, "cast":null, "genre":null}
        ]


        # persons.xml
        <persons>
          <person> 
            <firstName>Patty</firstName> 
            <lastName>Liar</lastName> 
            <age>20</age> 
            <address> 
              <streetAddress>18 2nd Street</streetAddress> 
              <city>New York</city> 
              <state>NY</state> 
              <postalCode>10021</postalCode> 
            </address> 
            <phoneNumbers> 
              <phoneNumber type="home">212 555-1234</phoneNumber> 
              <phoneNumber type="mobile">001 452-8819</phoneNumber> 
            </phoneNumbers> 
            <gender> 
              <type>female</type> 
            </gender> 
          </person> 
        </persons>


    - Here is the extractor for JSON data.  Note that the 'property' decorator is used to make
        'parsed_data()' appear as a normal attribute instead of a method.

        import json

        class JsonDataExtractor:

            def __init__(self, filepath):
                self.data = dict()
                with open(filepath, mode='r', encoding='utf-8') as f:
                    self.data = json.load(f)

            @property
            def parsed_data(self):
                return self.data


    - Here is the extractor for XML data.

        import xml.etree.ElementTree as etree

        class XmlDataExtractor:

            def __init__(self, filepath):
                self.tree = etree.parse(filepath)

            @property
            def parsed_data(self):
                return self.tree


    - Here, the 'dataextraction_factory()' function is a factory method.  It returns the correct 
        extractor based on the file extension.


        def data_extraction_factory(filepath):
            if filepath.endswith('json'):
                extractor = JsonDataExtractor
            elif filepath.endswith('xml'):
                extractor = XmlDataExtractor
            else:
                raise ValueError('Cannot extract data from {}'.format(filepath))
            return extractor(filepath)


        def extract_data_from(filepath):
            factory_obj = None
            try:
                factory_obj = data_extraction_factory(filepath)
            except ValueError as e:
                print(e)
            return factory_obj


        def main():
            # Process json file
            json_factory = extract_data_from('movies.json')
            json_data = json_factory.parsed_data

            print(f'Found: {len(json_data)} movies')
            for movie in json_data:
                print(f"Title: {movie['title']}")
                year = movie['year']
                if year:
                    print(f"Year: {year}")
                director = movie['director']
                if director:
                    print(f"Director: {director}")
                genre = movie['genre']
                if genre:
                    print(f"Genre: {genre}")
                print()


            # Process xml file
            xml_factory = extract_data_from('persons.xml')
            xml_data = xml_factory.parsed_data

            xml_factory = extract_data_from('data/person.xml')
            xml_data = xml_factory.parsed_data
            liars = xml_data.findall(f".//person[lastName='Liar']")
            print(f'found: {len(liars)} persons')
            for liar in liars:
                firstname = liar.find('firstName').text
                print(f'first name: {firstname}')
                lastname = liar.find('lastName').text
                print(f'last name: {lastname}')
                [print(f"phone number ({p.attrib['type']}):", p.text) 
                for p in liar.find('phoneNumbers')]
                print()


            # Trying to process other file types raises exception
            sqllite_factory = extract_data_from('person.sq3')